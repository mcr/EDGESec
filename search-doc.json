[{"title":"Hola","type":0,"sectionRef":"#","url":"blog/hola","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"Hello","type":0,"sectionRef":"#","url":"blog/hello-world","content":"Welcome to this blog. This blog is created with Docusaurus 2 alpha. This is a test post. A whole bunch of other information.","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"blog/welcome","content":"Blog features are powered by the blog plugin. Simply add files to the blog directory. It supports tags as well! Delete the whole directory if you don't want the blog features. As simple as that!","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"docs/about","content":"","keywords":""},{"title":"Licensing​","type":1,"pageTitle":"About","url":"docs/about#licensing","content":"The favicon is called &quot;Linksys WRT54GR wireless-G broadband Router with RangeBooster vector image&quot; was created by &quot;OpenClipart&quot; and used under the CC0 License/Public Domain. "},{"title":"EDGESec Intro","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":"Motivation​","type":1,"pageTitle":"EDGESec Intro","url":"docs/#motivation","content":"Internet technologies and current practice does not address security requirements of edgebased devices very well. It is a fact that the &quot;admin page&quot; of most routers, wifi devices and webcams is &quot;unsecured&quot;. It is perhaps not surprise that a recent Symnatec study showed that &quot;Routers account for 75% of infected IOT devices&quot;. The problem is that domain resolution on local Internets and HTTPS certificates do not work well together. Also HTTPS certs assume the private key is secure; how do I do this on a small edge device? EDGESec architecture and toolset implements novel user experience, key distribution, key storage and secure service discovery primitives to address current security shortcomings and provide a new vision for integrated cloud-edge services. "},{"title":"Problem need​","type":1,"pageTitle":"EDGESec Intro","url":"docs/#problem-need","content":"Most internet gateways, indeed most IP addressable device on an internal network have a fundamental weakness, they are not well secured. It is very hard to install web based certificates, that resolve to local IP addresses. As a result most broadband routers, internet gateways, IOT devices and webcams have insecure administrator access on the local network. Security assumes if you have access to the network you are trusted. This is clearly a mistaken assumption. Recent research by Symantec shows that 75% of reported attacks on IOT devices were due to router weaknesses. Edge routers, internal networks and more advanced IoT networking need fundamental innovation to address the security weakness. New architectures are needed for UI bootstrapping, key distribution, key storage, service discovery and addressing that will work as well at the edge as it does on the open internet. "},{"title":"Ambition​","type":1,"pageTitle":"EDGESec Intro","url":"docs/#ambition","content":"EDGESec toolset provides the following solutions to solve the main IoT gateway security challenges: A mechanism to do network isolation at the IoT gateway level. The network isolation will protect against external and internal entities attacking the connected IoT devices.A secure discovery and peer-to-peer connectivity mechanisms for IoT devices and gateway.A mechanism to store encryption keys and confidential router data.A mechanism to monitor connected IoT devices at the router level. By defining the minimal data collection standards, we have in place a powerful technique that will assist with the early detection and later containment of security threats coming from compromised IoT devices. We integrate all of the above strategies into a single opensource codebase lays the foundation for a secure IoT gateway and will be used as a standard for IoT device connectivity. "},{"title":"Technical approach​","type":1,"pageTitle":"EDGESec Intro","url":"docs/#technical-approach","content":"Network Control - The network isolation technique is implemented at the WiFi level protocol. We are using the VLAN mechanism to segment the network of connected IoT devices.Network Capture - We use packet sniffers and analysers to monitor and detect compromised IoT devices.Device Discovery - For device discovery and connectivity between IoT devices and IoT gateway we plan to use the efficient gRPC protocol.Secure Storage - To store the encryption keys and router confidential data we implemented a generic key value store on top of hardware secure storage. "},{"title":"Control Commands","type":0,"sectionRef":"#","url":"docs/commands","content":"","keywords":""},{"title":"EDGESec Commands​","type":1,"pageTitle":"Control Commands","url":"docs/commands#edgesec-commands","content":""},{"title":"PING_SUPERVISOR​","type":1,"pageTitle":"Control Commands","url":"docs/commands#ping_supervisor","content":"Usage: PING_SUPERVISOR Copy "},{"title":"ACCEPT_MAC​","type":1,"pageTitle":"Control Commands","url":"docs/commands#accept_mac","content":"Usage: ACCEPT_MAC mac_address vlanid Copy "},{"title":"DENY_MAC​","type":1,"pageTitle":"Control Commands","url":"docs/commands#deny_mac","content":"Usage: DENY_MAC mac_address Copy "},{"title":"ADD_NAT​","type":1,"pageTitle":"Control Commands","url":"docs/commands#add_nat","content":"Usage: ADD_NAT mac_address Copy "},{"title":"REMOVE_NAT​","type":1,"pageTitle":"Control Commands","url":"docs/commands#remove_nat","content":"Usage: REMOVE_NAT mac_address Copy "},{"title":"ASSIGN_PSK​","type":1,"pageTitle":"Control Commands","url":"docs/commands#assign_psk","content":"Usage: ASSIGN_PSK mac_address password Copy "},{"title":"GET_MAP​","type":1,"pageTitle":"Control Commands","url":"docs/commands#get_map","content":"Usage: GET_MAP mac_address Copy "},{"title":"GET_ALL​","type":1,"pageTitle":"Control Commands","url":"docs/commands#get_all","content":"Usage: GET_ALL Copy "},{"title":"ADD_BRIDGE​","type":1,"pageTitle":"Control Commands","url":"docs/commands#add_bridge","content":"Usage: ADD_BRIDGE mac_address_src mac_address_dst Copy "},{"title":"REMOVE_BRIDGE​","type":1,"pageTitle":"Control Commands","url":"docs/commands#remove_bridge","content":"Usage: REMOVE_BRIDGE mac_address_src mac_address_dst Copy "},{"title":"CLEAR_BRIDGE​","type":1,"pageTitle":"Control Commands","url":"docs/commands#clear_bridge","content":"Usage: CLEAR_BRIDGE mac_address Copy "},{"title":"GET_BRIDGES​","type":1,"pageTitle":"Control Commands","url":"docs/commands#get_bridges","content":"Usage: GET_BRIDGES Copy "},{"title":"REGISTER_TICKET​","type":1,"pageTitle":"Control Commands","url":"docs/commands#register_ticket","content":"Usage: REGISTER_TICKET mac_address device_label vlanid Copy "},{"title":"CLEAR_PSK​","type":1,"pageTitle":"Control Commands","url":"docs/commands#clear_psk","content":"Usage: CLEAR_PSK mac_address Copy "},{"title":"PUT_CRYPT​","type":1,"pageTitle":"Control Commands","url":"docs/commands#put_crypt","content":"Usage: PUT_CRYPT key_id value[base64] Copy "},{"title":"GET_CRYPT​","type":1,"pageTitle":"Control Commands","url":"docs/commands#get_crypt","content":"Usage: GET_CRYPT key_id Copy "},{"title":"GEN_RANDKEY​","type":1,"pageTitle":"Control Commands","url":"docs/commands#gen_randkey","content":"Usage: GEN_RANDKEY key_id key_size[bytes] Copy "},{"title":"GEN_PRIVKEY​","type":1,"pageTitle":"Control Commands","url":"docs/commands#gen_privkey","content":"Usage: GEN_PRIVKEY key_id key_size[bytes] Copy "},{"title":"GEN_PUBKEY​","type":1,"pageTitle":"Control Commands","url":"docs/commands#gen_pubkey","content":"Usage: GEN_PUBKEY public_key_id private_key_id Copy "},{"title":"GEN_CERT​","type":1,"pageTitle":"Control Commands","url":"docs/commands#gen_cert","content":"Usage: GEN_CERT certificate_kid private_key_id common_name Copy "},{"title":"ENCRYPT_BLOB​","type":1,"pageTitle":"Control Commands","url":"docs/commands#encrypt_blob","content":"Usage: ENCRYPT_BLOB key_id iv_id blob[base64] Copy "},{"title":"DECRYPT_BLOB​","type":1,"pageTitle":"Control Commands","url":"docs/commands#decrypt_blob","content":"Usage: DECRYPT_BLOB key_id iv_id blob[base64] Copy "},{"title":"DECRYPT_BLOB​","type":1,"pageTitle":"Control Commands","url":"docs/commands#decrypt_blob-1","content":"Usage: DECRYPT_BLOB key_id iv_id blob[base64] Copy "},{"title":"DECRYPT_BLOB​","type":1,"pageTitle":"Control Commands","url":"docs/commands#decrypt_blob-2","content":"Usage: SIGN_BLOB key_id blob[base64] Copy "},{"title":"HOSTAPD Commands​","type":1,"pageTitle":"Control Commands","url":"docs/commands#hostapd-commands","content":""},{"title":"PING​","type":1,"pageTitle":"Control Commands","url":"docs/commands#ping","content":"Usage: PING Copy "},{"title":"RELOG​","type":1,"pageTitle":"Control Commands","url":"docs/commands#relog","content":"Usage: RELOG Copy "},{"title":"NOTE​","type":1,"pageTitle":"Control Commands","url":"docs/commands#note","content":"Usage: NOTE text Copy "},{"title":"STATUS​","type":1,"pageTitle":"Control Commands","url":"docs/commands#status","content":"Usage: STATUS Copy "},{"title":"STATUS-DRIVER​","type":1,"pageTitle":"Control Commands","url":"docs/commands#status-driver","content":"Usage: STATUS-DRIVER Copy "},{"title":"MIB​","type":1,"pageTitle":"Control Commands","url":"docs/commands#mib","content":"Usage: MIB Copy "},{"title":"STA-FIRST​","type":1,"pageTitle":"Control Commands","url":"docs/commands#sta-first","content":"Usage: STA-FIRST Copy "},{"title":"STA​","type":1,"pageTitle":"Control Commands","url":"docs/commands#sta","content":"Usage: STA mac_address Copy "},{"title":"STA-NEXT​","type":1,"pageTitle":"Control Commands","url":"docs/commands#sta-next","content":"Usage: STA-NEXT mac_address Copy "},{"title":"ATTACH​","type":1,"pageTitle":"Control Commands","url":"docs/commands#attach","content":"Usage: ATTACH Copy "},{"title":"DETACH​","type":1,"pageTitle":"Control Commands","url":"docs/commands#detach","content":"Usage: DETACH Copy "},{"title":"NEW_STA​","type":1,"pageTitle":"Control Commands","url":"docs/commands#new_sta","content":"Usage: NEW_STA mac_address Copy "},{"title":"DEAUTHENTICATE​","type":1,"pageTitle":"Control Commands","url":"docs/commands#deauthenticate","content":"Usage: DEAUTHENTICATE mac_address reason=value[1-45] Copy "},{"title":"DISASSOCIATE​","type":1,"pageTitle":"Control Commands","url":"docs/commands#disassociate","content":"Usage: DISASSOCIATE mac_address reason=value[1-45] Copy "},{"title":"POLL_STA​","type":1,"pageTitle":"Control Commands","url":"docs/commands#poll_sta","content":"Usage: POLL_STA mac_address Copy "},{"title":"STOP_AP​","type":1,"pageTitle":"Control Commands","url":"docs/commands#stop_ap","content":"Usage: STOP_AP Copy "},{"title":"GET_CONFIG​","type":1,"pageTitle":"Control Commands","url":"docs/commands#get_config","content":"Usage: GET_CONFIG Copy "},{"title":"RELOAD_WPA_PSK​","type":1,"pageTitle":"Control Commands","url":"docs/commands#reload_wpa_psk","content":"Usage: RELOAD_WPA_PSK Copy "},{"title":"RELOAD​","type":1,"pageTitle":"Control Commands","url":"docs/commands#reload","content":"Usage: RELOAD Copy "},{"title":"ENABLE​","type":1,"pageTitle":"Control Commands","url":"docs/commands#enable","content":"Usage: ENABLE Copy "},{"title":"DISABLE​","type":1,"pageTitle":"Control Commands","url":"docs/commands#disable","content":"Usage: DISABLE Copy "},{"title":"UPDATE_BEACON​","type":1,"pageTitle":"Control Commands","url":"docs/commands#update_beacon","content":"Usage: UPDATE_BEACON Copy "},{"title":"VENDOR​","type":1,"pageTitle":"Control Commands","url":"docs/commands#vendor","content":"Not understood yet. Usage: VENDOR cmd Copy "},{"title":"ERP_FLUSH​","type":1,"pageTitle":"Control Commands","url":"docs/commands#erp_flush","content":"Usage: ERP_FLUSH Copy "},{"title":"LOG_LEVEL​","type":1,"pageTitle":"Control Commands","url":"docs/commands#log_level","content":"Usage: LOG_LEVEL Copy "},{"title":"DRIVER_FLAGS​","type":1,"pageTitle":"Control Commands","url":"docs/commands#driver_flags","content":"Usage: DRIVER_FLAGS Copy "},{"title":"TERMINATE​","type":1,"pageTitle":"Control Commands","url":"docs/commands#terminate","content":"Usage: TERMINATE Copy "},{"title":"ACCEPT_ACL​","type":1,"pageTitle":"Control Commands","url":"docs/commands#accept_acl","content":"Usage: ACCEPT_ACL ADD_MAC mac_address ACCEPT_ACL DEL_MAC mac_address ACCEPT_ACL SHOW ACCEPT_ACL CLEAR Copy "},{"title":"DENY_ACL​","type":1,"pageTitle":"Control Commands","url":"docs/commands#deny_acl","content":"Usage: DENY_ACL ADD_MAC mac_address DENY_ACL DEL_MAC mac_address DENY_ACL SHOW DENY_ACL CLEAR Copy "},{"title":"ATTACH​","type":1,"pageTitle":"Control Commands","url":"docs/commands#attach-1","content":"Usage: ATTACH Copy "},{"title":"DETTACH​","type":1,"pageTitle":"Control Commands","url":"docs/commands#dettach","content":"Usage: DETTACH Copy "},{"title":"Network Capture","type":0,"sectionRef":"#","url":"docs/capture","content":"","keywords":""},{"title":"The Network Capture architecture​","type":1,"pageTitle":"Network Capture","url":"docs/capture#the-network-capture-architecture","content":"The network capture has the purpose of monitoring network traffic for each connected device. The resulting traffic analytics is sent to the network controller for device management. The network capture contains the following services: Packet decoderPacket captureSQLite header storerRaw packet storerGRPC SynchroniserDevice monitoring The capture service is implemented as a standalone executable that can be run on demand by the network controller. The configuration of the capture service is depicted below: struct capture_conf { char capture_interface[IFNAMSIZ]; bool promiscuous; bool immediate; uint16_t buffer_timeout; uint16_t process_interval; bool file_write; bool db_write; bool db_sync; char db_path[MAX_OS_PATH_LEN]; char db_sync_address[MAX_WEB_PATH_LEN]; uint16_t db_sync_port; char *filter; }; Copy The capture service can be run on a given network interface with a given filter. The capture also has the ability to store the processed packet in SQLite databases or raw format. The databases can be synchronised with the cloud for remote access. "},{"title":"Packet decoder​","type":1,"pageTitle":"Network Capture","url":"docs/capture#packet-decoder","content":"The packet decoder extract the metadata from captured packet. The below structure represents all the protocols that are currently being decoded: struct capture_packet { struct ether_header *ethh; struct ether_arp *arph; struct ip *ip4h; struct ip6_hdr *ip6h; struct tcphdr *tcph; struct udphdr *udph; struct icmphdr *icmp4h; struct icmp6_hdr *icmp6h; struct dns_header *dnsh; struct mdns_header *mdnsh; struct dhcp_header *dhcph; uint64_t timestamp; uint32_t caplen; uint32_t length; uint32_t ethh_hash; uint32_t arph_hash; uint32_t ip4h_hash; uint32_t ip6h_hash; uint32_t tcph_hash; uint32_t udph_hash; uint32_t icmp4h_hash; uint32_t icmp6h_hash; uint32_t dnsh_hash; uint32_t mdnsh_hash; uint32_t dhcph_hash; int count; }; Copy For each decoded packet the service stores the hash of the header as well as the timestamp. "},{"title":"Packet capture​","type":1,"pageTitle":"Network Capture","url":"docs/capture#packet-capture","content":"The packet capture implements the actual network sniffing process. Currently it uses pcap library. But it also allow interfacing with PF_RING module that implements zero-copy technique. "},{"title":"SQLite storer​","type":1,"pageTitle":"Network Capture","url":"docs/capture#sqlite-storer","content":"The SQLite storer implements the storage process for packet metadata into sqlite databases. Below is the list of schemas created by the SQLite storer that can be used by any application to query the packets: CREATE TABLE eth (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, ether_dhost TEXT, ether_shost TEXT, ether_type INTEGER,PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE arp (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, arp_hrd INTEGER, arp_pro INTEGER, arp_hln INTEGER, arp_pln INTEGER, arp_op INTEGER, arp_sha TEXT, arp_spa TEXT, arp_tha TEXT, arp_tpa TEXT, PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE ip4 (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, ip_hl INTEGER, ip_v INTEGER, ip_tos INTEGER, ip_len INTEGER, ip_id INTEGER, ip_off INTEGER, ip_ttl INTEGER, ip_p INTEGER, ip_sum INTEGER, ip_src TEXT, ip_dst TEXT, PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE ip6 (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, ip6_un1_flow INTEGER, ip6_un1_plen INTEGER, ip6_un1_nxt INTEGER, cip6_un1_hlim INTEGER, ip6_un2_vfc INTEGER, ip6_src TEXT, ip6_dst TEXT, PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE tcp (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, source INTEGER, dest INTEGER, seq INTEGER, ack_seq INTEGER, res1 INTEGER, doff INTEGER, fin INTEGER, syn INTEGER, rst INTEGER, psh INTEGER, ack INTEGER, urg INTEGER, window INTEGER, check_p INTEGER, urg_ptr INTEGER, PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE udp (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, source INTEGER, dest INTEGER, len INTEGER, check_p INTEGER, PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE icmp4 (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, type INTEGER, code INTEGER, checksum INTEGER, gateway INTEGER, PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE icmp6 (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, icmp6_type INTEGER, icmp6_code INTEGER, icmp6_cksum INTEGER, icmp6_un_data32 INTEGER, PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE dns (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, tid INTEGER, flags INTEGER, nqueries INTEGER, nanswers INTEGER, nauth INTEGER, nother INTEGER, PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE mdns (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, tid INTEGER, flags INTEGER, nqueries INTEGER, nanswers INTEGER, nauth INTEGER, nother INTEGER, PRIMARY KEY (hash, timestamp, ethh_hash)) CREATE TABLE dhcp (hash INTEGER NOT NULL, timestamp INTEGER NOT NULL, ethh_hash INTEGER NOT NULL, caplen INTEGER, length INTEGER, op INTEGER, htype INTEGER, hlen INTEGER, hops INTEGER, xid INTEGER, secs INTEGER, flags INTEGER, ciaddr TEXT, yiaddr TEXT, siaddr TEXT, giaddr TEXT, PRIMARY KEY (hash, timestamp, ethh_hash)) Copy Ever column in the respective table contains the hash of the Ethernet protocol that encapsulated the upper layers of the internet protocol suite as well as the capture timestamp. "},{"title":"Raw packet storer​","type":1,"pageTitle":"Network Capture","url":"docs/capture#raw-packet-storer","content":"The raw packet storer stores the raw packet into pcap files and the metadata for each file is stored in a SQLite database. The file name for each packet is randomly generate and subsequently the name is stored in a SQLite database together with the timestamp and packet length. The schema for the SQLite database is depicted below: CREATE TABLE meta (id TEXT, timestamp INTEGER NOT NULL, name TEXT, interface TEXT, filter TEXT, caplen INTEGER, length INTEGER, PRIMARY KEY (id, timestamp, interface)) Copy "},{"title":"GRPC Synchroniser​","type":1,"pageTitle":"Network Capture","url":"docs/capture#grpc-synchroniser","content":"The GRPC syncroniser service implements the syncronisation process to the cloud for stored packet data as well as other tool data. The syncroniser can function in two ways: Forward - the syncroniser pushes the tool data to a cloud endpointReverse - the syncroniser connects to a cloud endpoint, which subsequently makes a reverse connection to the syncroniser service The syncronisation process is based on gRPC protocol, where the syncroniser service acts as a client and the cloud endpoint as a server. The connection can be made secure (using TLS) by providing a server certificate. The gRPC protocol uses procol buffers to define the remote execution function. The forward service is implemented by the below protocol buffer: syntax = &quot;proto3&quot;; package sqlite_sync; // The synchroniser service definition. service Synchroniser { // Registers a db rpc RegisterDb (RegisterDbRequest) returns (RegisterDbReply) {} // Synchronise db statement rpc SyncDbStatement (SyncDbStatementRequest) returns (SyncDbStatementReply) {} } // The request message containing the db name and other params. message RegisterDbRequest { string name = 1; } // The response message containing the registration status message RegisterDbReply { uint32 status = 1; } message SyncDbStatementRequest { string name = 1; string statement = 2; } message SyncDbStatementReply { uint32 status = 1; } Copy The forward synchroniser is used for cases when one needs to syncronise only the metadata to the cloud. It is implemented as a queue that pushes the packets at given intervals of time. "},{"title":"Device monitoring​","type":1,"pageTitle":"Network Capture","url":"docs/capture#device-monitoring","content":"The device monitoring service decodes the network traffic and assembles nettwork flow. Each flow is denoted by a source and destination MAC address, and protcol type. For each flow the device monitoring service calculates a fingerpint using the SHA256 algorithm. The flow results in the following structure: struct nDPI_flow_meta { char src_mac_addr[MACSTR_LEN]; char dst_mac_addr[MACSTR_LEN]; char protocol[MAX_PROTOCOL_NAME_LEN]; char hash[SHA256_HASH_LEN]; char query[MAX_QUERY_LEN]; }; Copy where src_mac_addr is the source MAC address, dst_mac_addr is the destination MAC address, protocol is the ID of the identified network protocol, hash is the fingerprint of the flow and query is the optional query string. The optional query string is dependent on the protocol type. For DNS, mDNS and TLS it is the same as the requested host name. Each flow is stored in a sqlite database with teh followinf schema: CREATE TABLE fingerprint (mac TEXT NOT NULL, protocol TEXT, fingerprint TEXT, timestamp INTEGER NOT NULL, query TEXT, PRIMARY KEY (mac, timestamp)); Copy The timestamp is given as 64 bit microseconds value and the fingerprint string is encoded in base64. An example of the fingerprint table rows are below: MACPROTOCOL\tFINGERPRINT\tTIMESTAMP\tQUERY84:e3:42:3a:cb:2f\tTLS.Amazon\tmI1ENXMPBQDVjwGh/o0bLSrD8+O2O5RCFQLbUVt4lzI\t1625055051481102 9c:ef:d5:fd:db:56\tTLS.Amazon\tmI1ENXMPBQDVjwGh/o0bLSrD8+O2O5RCFQLbUVt4lzI\t1625055051481102 84:e3:42:3a:cb:2f\tDNS\tNqRTRWiNdfG4zMkiXE9P0eRQIefPgMYV/vXUymxdvNw\t1625055072748967 9c:ef:d5:fd:db:56\tDNS\tNqRTRWiNdfG4zMkiXE9P0eRQIefPgMYV/vXUymxdvNw\t1625055072748967 The entries of the fingerprint table can be queried using the supervisor service. For instance to retrieve all fingerprints for the MAC address 84:e3:42:3a:cb:2f one could use the following command: QUERY_FINGERPRINT 84:e3:42:3a:cb:2f 0 &gt;= all Copy To retrieve all the fingerprints up to a given timestamp one could use the following command: QUERY_FINGERPRINT 84:e3:42:3a:cb:2f 1625055051481102 &lt;= all Copy To retrieve all the fingerprints for the DNS protocol one could use the following command: QUERY_FINGERPRINT 84:e3:42:3a:cb:2f 0 &gt;= DNS Copy "},{"title":"Configuration File","type":0,"sectionRef":"#","url":"docs/config","content":"","keywords":""},{"title":"[system] group​","type":1,"pageTitle":"Configuration File","url":"docs/config#system-group","content":"The system group contains all the parameters that are reponsible to configure the edgesec system tool paths, the hashes of the system binaries and tool flags. "},{"title":"binPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#binpath-string","content":"A list of systems binary paths separated with &quot;:&quot; used by the edgesec tool to configure interfaces, etc. "},{"title":"hashIpCommand (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#hashipcommand-string","content":"A list of hashes for each system binary used by the tool. [WIP] "},{"title":"createInterfaces (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#createinterfaces-boolean","content":"edgesec will create subnetnetwork interfaces if the flag is set to true. If set to false one will have to use a similar service to dhcpcd to preconfigure the network interfaces. "},{"title":"ignoreErrorOnIfCreate (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#ignoreerroronifcreate-boolean","content":"If set to true, edgesec will ignore the &quot;network interface already exists&quot; error. This flag is to be used if the network interfaces are already preconfigured. "},{"title":"allowAllConnections (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#allowallconnections-boolean","content":"If set to true, edgesec will allow all WiFi connection requests regarding of the MAC value. "},{"title":"allowAllNat (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#allowallnat-boolean","content":"If set to true, edgesec will allow all NAT connection requests regarding of the MAC value. "},{"title":"apDetect (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#apdetect-boolean","content":"If set to true, edgesec will try to detect the WiFi network interfaces that supports VLAN capability. The detected network interface will be used by hostapd service to create an AP. "},{"title":"generateSsid (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#generatessid-boolean","content":"If set to true, edgesec will generate the SSID WiFi name based on hostname. If false the SSID name will be ssid param from ap section. "},{"title":"allocateVlans (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#allocatevlans-boolean","content":"If set to true, edgesec will randomly assign a VLAN ID to a newly connected device. "},{"title":"defaultOpenVlanId (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#defaultopenvlanid-integer","content":"The default VLAN ID positive integer number assigned to new devices if allowAllConnections flag is set to true. "},{"title":"quarantineVlanId (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#quarantinevlanid-integer","content":"The VLAN ID assigned to devices that are quarantined. "},{"title":"riskScore (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#riskscore-integer","content":"The risk score threshold for a device to be quarantined. "},{"title":"killRunningProcess (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#killrunningprocess-boolean","content":"If set to true the current running edgesec will terminate exisiting running edgesec processes. "},{"title":"execAp (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#execap-boolean","content":"If set to true, edgesec will execute the hostapd service using excve system command. If set to false the hostapd service has to be run before executing edgesec. "},{"title":"execRadius (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#execradius-boolean","content":"If set to true, edgesec will execute the radius service. "},{"title":"execDhcp (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#execdhcp-boolean","content":"If set to true, edgesec will execute the dhcp service. "},{"title":"execCapture (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#execcapture-boolean","content":"If set to true, edgesec will execute the capture service. "},{"title":"execMdnsForward (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#execmdnsforward-boolean","content":"If set to true, edgesec will execute the mdnsf service. "},{"title":"execIptables (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#execiptables-boolean","content":"If set to true, edgesec will execute the iptables command. "},{"title":"setIpForward (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#setipforward-boolean","content":"If set to true edgesec will set the ip forward os system param. "},{"title":"dbPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dbpath-string","content":"The path to the db folder. "},{"title":"cryptDbPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#cryptdbpath-string","content":"The path to the crypt sqlite db. "},{"title":"cryptKeyId (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#cryptkeyid-string","content":"The master key ID for the crypt sqlite db. "},{"title":"pidFilePath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#pidfilepath-string","content":"The path to the edgesec PID file. "},{"title":"[capture] group​","type":1,"pageTitle":"Configuration File","url":"docs/config#capture-group","content":"The capture group contains all the parameters that are reponsible to configure the capture app service. "},{"title":"captureBinPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#capturebinpath-string","content":"The path to the capsrv service. "},{"title":"captureInterface (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#captureinterface-string","content":"The name of the capture interface. If set to &quot;any&quot; the service will traffic from all interfaces. "},{"title":"filter (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#filter-string","content":"The pcap lib capture filter. "},{"title":"promiscuous (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#promiscuous-boolean","content":"If set to true the capture interface is set to promiscuous mode. The default value is false. "},{"title":"bufferTimeout (number)​","type":1,"pageTitle":"Configuration File","url":"docs/config#buffertimeout-number","content":"The timeout in milliseconds to read a packet. The default value is 10. "},{"title":"processInterval (number)​","type":1,"pageTitle":"Configuration File","url":"docs/config#processinterval-number","content":"The interval in milliseconds to process a packet from the queue. The default value is 10. "},{"title":"immediate (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#immediate-boolean","content":"If set to true the capture interface is set to immediate mode. The default value is false. "},{"title":"analyser (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#analyser-string","content":"The analyser name for the capture service. Currently supported default and ndpi analysers. "},{"title":"fileWrite (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#filewrite-boolean","content":"Write the packet data to file(s). "},{"title":"dbWrite (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dbwrite-boolean","content":"If set to true the capture service will store the packet into an sqlite db "},{"title":"dbSync (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dbsync-boolean","content":"If set to true the sqlite packets db will be synced "},{"title":"dbSyncAddress (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dbsyncaddress-string","content":"The web address for sqlite syncing "},{"title":"dbSyncPort (number)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dbsyncport-number","content":"The port of the web address for sqlite syncing "},{"title":"syncCaPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#synccapath-string","content":"The path to the certificate authority file used for gRPC syncing "},{"title":"command (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#command-string","content":"The UNIX domain command used by the capture service "},{"title":"syncStoreSize (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#syncstoresize-integer","content":"Number of capture strings to store in memory before "},{"title":"syncSendSize (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#syncsendsize-integer","content":"Number of string to send (sync) from the memory buffer "},{"title":"captureStoreSize (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#capturestoresize-integer","content":"Number of pcap Kb to store before cleaning. Used by capture cleaner service "},{"title":"[supervisor] group​","type":1,"pageTitle":"Configuration File","url":"docs/config#supervisor-group","content":"The supervisor group defines the parameters to run the supervisor service. "},{"title":"domainServerPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#domainserverpath-string","content":"The absolute path to the UNIX domain socket used by the supervisor service. "},{"title":"delim (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#delim-integer","content":"The decimal ASCII number used to delimit command parameters. "},{"title":"[ap] group​","type":1,"pageTitle":"Configuration File","url":"docs/config#ap-group","content":"The ap groups defines all the paremeters to run ap service. Most of the parameters are inherited from the hostapd config file. "},{"title":"apBinPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#apbinpath-string","content":"Absolute path to the hostapd binary. "},{"title":"apFilePath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#apfilepath-string","content":"Absolute path to the hostapd configuration file. "},{"title":"apLogPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#aplogpath-string","content":"Absolute path to the hostapd log file. If empty no log file is generated "},{"title":"interface (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#interface-string","content":"Inherited from hostapd.conf "},{"title":"vlanTaggedInterface (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#vlantaggedinterface-string","content":"Interface name for vlan tagging "},{"title":"ssid (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#ssid-string","content":"Inherited from hostapd.conf "},{"title":"wpaPassphrase (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#wpapassphrase-string","content":"Inherited from hostapd.conf "},{"title":"bridge (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#bridge-string","content":"Inherited from hostapd.conf "},{"title":"driver (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#driver-string","content":"Inherited from hostapd.conf "},{"title":"hwMode (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#hwmode-string","content":"Inherited from hostapd.conf "},{"title":"channel (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#channel-integer","content":"Inherited from hostapd.conf "},{"title":"wmmEnabled (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#wmmenabled-integer","content":"Inherited from hostapd.conf "},{"title":"authAlgs (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#authalgs-integer","content":"Inherited from hostapd.conf "},{"title":"wpa (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#wpa-integer","content":"Inherited from hostapd.conf "},{"title":"wpaKeyMgmt (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#wpakeymgmt-string","content":"Inherited from hostapd.conf "},{"title":"rsnPairwise (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#rsnpairwise-string","content":"Inherited from hostapd.conf "},{"title":"ctrlInterface (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#ctrlinterface-string","content":"Inherited from hostapd.conf "},{"title":"macaddrAcl (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#macaddracl-integer","content":"Inherited from hostapd.conf "},{"title":"dynamicVlan (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dynamicvlan-integer","content":"Inherited from hostapd.conf "},{"title":"vlanBridge (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#vlanbridge-string","content":"Inherited from hostapd.conf "},{"title":"vlanFile (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#vlanfile-string","content":"Inherited from hostapd.conf "},{"title":"loggerStdout (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#loggerstdout-integer","content":"Inherited from hostapd.conf "},{"title":"loggerStdoutLevel (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#loggerstdoutlevel-integer","content":"Inherited from hostapd.conf "},{"title":"loggerSyslog (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#loggersyslog-integer","content":"Inherited from hostapd.conf "},{"title":"loggerSyslogLevel (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#loggersysloglevel-integer","content":"Inherited from hostapd.conf "},{"title":"ignoreBroadcastSsid (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#ignorebroadcastssid-integer","content":"Inherited from hostapd.conf "},{"title":"wpaPskRadius (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#wpapskradius-integer","content":"Inherited from hostapd.conf "},{"title":"[radius] group​","type":1,"pageTitle":"Configuration File","url":"docs/config#radius-group","content":"The radius group defines the port, IP and network mask for creating the RADIUS server. "},{"title":"port (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#port-integer","content":"The port value for the RADIUS server. "},{"title":"clientIP (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#clientip-string","content":"The connecting client IP with format x.y.z.q. Current config uses localhost (127.0.0.1). "},{"title":"clientMask (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#clientmask-integer","content":"The client IP network mask encoding bit-length of the prefix. "},{"title":"serverIP (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#serverip-string","content":"The RADIUS server IP. Current config uses localhost (127.0.0.1). "},{"title":"serverMask (integer)​","type":1,"pageTitle":"Configuration File","url":"docs/config#servermask-integer","content":"The server IP network mask encoding bit-length of the prefix. "},{"title":"secret (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#secret-string","content":"The RADIUS server password used by the clients. "},{"title":"[nat] group​","type":1,"pageTitle":"Configuration File","url":"docs/config#nat-group","content":"The nat group defines the parameter for NAT interface. "},{"title":"natInterface (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#natinterface-string","content":"The NAT interface name. "},{"title":"[dns] group​","type":1,"pageTitle":"Configuration File","url":"docs/config#dns-group","content":"The dns groups defines the parameters for the DNS server configuration. "},{"title":"servers (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#servers-string","content":"A comma delimited string of dns server IP addresses with the format x.y.z.q,a.b.c.d,.... "},{"title":"mdnsBinPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#mdnsbinpath-string","content":"The path to the mdnsf service. "},{"title":"mdnsReflectIp4 (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#mdnsreflectip4-boolean","content":"If set to true the mdns service will reflect IP4 mdns packets. "},{"title":"mdnsReflectIp6 (boolean)​","type":1,"pageTitle":"Configuration File","url":"docs/config#mdnsreflectip6-boolean","content":"If set to true the mdns service will reflect IP6 mdns packets. "},{"title":"mdnsFilter (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#mdnsfilter-string","content":"The mdns service filter string used by pcap library to track internal IP connections. The filter is based on the interface IP addresses. "},{"title":"[dhcp] group​","type":1,"pageTitle":"Configuration File","url":"docs/config#dhcp-group","content":"The dhpc groups defines the parameters for the DHCP server configuration. "},{"title":"dhcpBinPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dhcpbinpath-string","content":"The path to the DHCP server "},{"title":"dhcpConfigPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dhcpconfigpath-string","content":"The path to the DHCP server configuration file "},{"title":"dhcpScriptPath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dhcpscriptpath-string","content":"The path to the DHCP server aditional executable script "},{"title":"dhcpLeasefilePath (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dhcpleasefilepath-string","content":"The path to the DHCP lease file "},{"title":"dhcpRangei (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#dhcprangei-string","content":"The DHCP configuration indexed by i≥0. It has the followig format: vlanid,ip_low,ip_up,mask,time Copy ,where vlanid - the VLAN IDip_low - the lower bound for IP subnetup_low - the upper bound for IP subnetmask - the subnet masktime - the lease time (dnsmasq format) "},{"title":"[interfaces] groups​","type":1,"pageTitle":"Configuration File","url":"docs/config#interfaces-groups","content":"The interfaces group defines the parameters for WiFi subnet interfaces. "},{"title":"ifi (string)​","type":1,"pageTitle":"Configuration File","url":"docs/config#ifi-string","content":"The if indexed by i≥0 defines the network interfaces for a particular subnet. It has the following format: vlanid,ip0,ipn,mask Copy where vlanid - is the VLAN ID,ip0 - the subnet starting IP address with format x.y.z.q,ipn - the subnet ending IP address with format x.y.z.q andmask - the subnet mask IP address with format x.y.z.q. "},{"title":"Network Control","type":0,"sectionRef":"#","url":"docs/control","content":"","keywords":""},{"title":"The Network Control architecture​","type":1,"pageTitle":"Network Control","url":"docs/control#the-network-control-architecture","content":"The network architecture of the EDGESec tool consist of several services that create and manage connected IoT devices. The below diagram depicts the architecture, which consists of six services: Subnet serviceSupervisor serviceRADIUS serverSoftware AP serviceDHCP serviceState machine serviceNetwork Capture serviceCrypt service  The management of each service is controlled by the tool engine, which has the ability to configure and start the execution process. First, the engine executes the supervisor service, which has the role of registering network joining and DHCP requests. It also exposes a command interface in the form of a UNIX domain socket that can be used by other application or services the control the connected newtork devices. Second, the engine executes the software access point (AP) service that creates a managed AP, which allows every network device to connect to it. The AP allows setting individual network joining credential for every connecting devices. Third, the engine executes the subnet service which creates subnets for give virtual LAN (VLAN) IDs and IP ranges. The software AP service maps subsequently a connected network device to a subnet. Fourth, the engine executes the DHCP service that has the role of assigning IP addresses to connected devices. Fifth, the engine executes the RADIUS server, which sends access control information to the software AP. The access information contains the network joining credentials and the accept/deny MAC address information. Sixth, the engine execute the state machine service, which represents the core of the network monitoring and management process. The state machine monitors the state of each connected network device by employing information from the supevisor service. It also uses the capture service, which executes self contained traffic capturing routines to monitor the flow of packet and disect identify the device types. "},{"title":"The Subnet service​","type":1,"pageTitle":"Network Control","url":"docs/control#the-subnet-service","content":"This service creates subnets and maps VLAN IDs to a subnet IP range. It uses the Netlink protocol library suite to access network kernel functionality from the user space. "},{"title":"The Supervisor service​","type":1,"pageTitle":"Network Control","url":"docs/control#the-supervisor-service","content":"This service supervises the assignment of IP addresses and manages the connectivity structures for a network devices. It exposes a UNIX domain socket as the control interface that can be used by other applications to execute the following commands: PING_SUPERVISOR - Ping the supervisorHOSTAPD_IF - Return the hostapd (software AP) control interfaceACCEPT_MAC - Add a MAC address to the accept tlistDENY_MAC - Remove a MAC address from the accept listADD_NAT - Add a MAC address to network address translation (NAT)REMOVE_NAT - Remove a MAC address from NATASSIGN_PSK - Assign a network credential to a MAC addressGET_MAP - Return the MAC mapper structure for a given MAC addressGET_ALL - Return all MAC mappers structuresSET_IP - Map an IP address to a MAC addressADD_BRIDGE - Add two MAC addresses to a bridgeREMOVE_BRIDGE - Remove two MAC addresses from a bridgeGET_BRIDGES - List all MAc bridges The supervisor context below describes the stored structure for all network connected devices: struct supervisor_context { hmap_mac_conn *mac_mapper; hmap_if_conn *if_mapper; hmap_vlan_conn *vlan_mapper; bool allow_all_connections; char hostapd_ctrl_if_path[MAX_OS_PATH_LEN]; uint8_t wpa_passphrase[AP_SECRET_LEN]; ssize_t wpa_passphrase_len; char nat_interface[IFNAMSIZ]; int default_open_vlanid; UT_array *config_ifinfo_array; struct bridge_mac_list *bridge_list; }; Copy It contains the mappers between MAC address, VLAN ID, IP address and network credentials. It also contains the mappers for NAT and network bridges. The interaction between the supervisor and other services is depicted below.  The supervisor and DHPC are separate services that intercat through the control interface. When the DHCP assigns an IP address to a network device it sends the assigned IP to the supervisor through control interface. Subsequently the supervisor saves the IP in the corresponding mapping table. The supervisor also notifies the radius server on the MAC addresses and credentials it can use. Finally the supervisaor also uses the iptables routines to configure the NAT and bridge functinality for each network device. "},{"title":"Bridge​","type":1,"pageTitle":"Network Control","url":"docs/control#bridge","content":"The supervisor allows connecting two network devices into a bridge. Below is a diagram depicting an example connection between five network devices:  It important to note that the connection is not transitive. The control interface allows any application to list, add and remove bridge connections. When a connection is being added or removed the corresponding mapping in the supervisor context and the iptables entries are modified. "},{"title":"NAT​","type":1,"pageTitle":"Network Control","url":"docs/control#nat","content":"The supervisor can allow or deny network access to a network device. The below picture depicts an example of NAT connection for several devices.  As for bridges when a NAT connection is added or removed the iptables is modified accordinlgy. "},{"title":"Software AP service​","type":1,"pageTitle":"Network Control","url":"docs/control#software-ap-service","content":"The software AP service creates a WiFi access points for network device connection. Currently the edgesec tool uses the hostap software AP service. The configuration structure for the AP service is depicted below: struct apconf { char ap_bin_path[MAX_OS_PATH_LEN]; char ap_file_path[MAX_OS_PATH_LEN]; char ap_log_path[MAX_OS_PATH_LEN]; char interface[IFNAMSIZ]; char ssid[AP_NAME_LEN]; char wpa_passphrase[AP_SECRET_LEN]; char bridge[IFNAMSIZ]; char driver[AP_DRIVE_LEN]; char hw_mode[AP_HWMODE_LEN]; int channel; int wmm_enabled; int auth_algs; int wpa; char wpa_key_mgmt[AP_WPA_KEY_MGMT_LEN]; char rsn_pairwise[AP_RSN_PAIRWISE_LEN]; char ctrl_interface[MAX_OS_PATH_LEN]; int macaddr_acl; int dynamic_vlan; char vlan_bridge[IFNAMSIZ]; char vlan_file[MAX_OS_PATH_LEN]; int logger_stdout; int logger_stdout_level; int logger_syslog; int logger_syslog_level; int ignore_broadcast_ssid; int wpa_psk_radius; }; Copy The main components of the structure are interface, ssid, wpa_passphrase and ctrl_interface. The interface parameters sets the network interface of the AP. The ssid denotes the visible name of the access point to which network devices can connect to. The wpa_passphrase denotes the network credentials to join the AP abd the ctrl_interface is the UNIX domain socket to manage the AP. Below is a diagram depicting the connection between the AP and other network services:  The software AP, which in this case is implemented by hostapd, creates a RADIUS client. The RADIUS client equires for network credentials from RADIUS server. Subsequently the RADIUS server returns the access/deny and credentials packet. The access list and credentials are obtained from the supervisor service. "},{"title":"Creating a .deb","type":0,"sectionRef":"#","url":"docs/deb","content":"","keywords":""},{"title":"Using GitHub Actions (recommended)​","type":1,"pageTitle":"Creating a .deb","url":"docs/deb#using-github-actions-recommended","content":"Update debian/changelog and make a new version.Create a new GitHub Release, using the branch where you pushed the updated changelog.After creating a Release (and when it's NOT a draft), the create-debs.ymlwill automatically compile the .deb files, and upload them as part of the Release you made. "},{"title":"Build Environment​","type":1,"pageTitle":"Creating a .deb","url":"docs/deb#build-environment","content":"The recommended way of building a .deb is using the software pbuilder. This will automatically run sudo apt install [...&lt;dependencies&gt;]in a chroot environment. However, this does mean you need sudo access, even though you are only installing into a chroot environment. Additionally, you also need access to chroot, so pbuilder does not work in a container like docker/podman. "},{"title":"PBuild​","type":1,"pageTitle":"Creating a .deb","url":"docs/deb#pbuild","content":"Install build dependencies: sudo apt install gnupg pbuilder debhelper -y Copy Then create a pbuild environment (basically a chroot jail). This lets us install apt packages without affecting our OS. Replace --distribution focal with the OS you are using. sudo pbuilder create --debootstrapopts --variant=buildd --distribution focal Copy Next, you must have USENETWORK=yes enabled in your /etc/pbuilderrc file. This is so that cmake can download files while building. # Enable network access, since `cmake` downloads dependencies USENETWORK=yes Copy Finally, you can build the .deb file with: pdebuild --debbuildopts &quot;-us -uc&quot; Copy The meaning of the options are: -debbuildopts &lt;debbuild_opts&gt;: Options to pass to debbuild. See debbuild options above in the Podman section. &quot;-us -uc&quot; means do not sign the source package and .changes file. By default, the .deb file will be located in /var/cache/pbuilder/result/. "},{"title":"Cross-compiling​","type":1,"pageTitle":"Creating a .deb","url":"docs/deb#cross-compiling","content":"First of all, install pbuilder, which automatically downloads dependencies and does the cross-compiling for you. sudo apt install gnupg pbuilder debhelper -y Copy Then, edit /etc/pbuilderrc and enable the following settings: # Enable network access, since `cmake` downloads dependencies USENETWORK=yes # Faster than default, and is requried if we want to do cross-compiling PBUILDERSATISFYDEPENDSCMD=&quot;/usr/lib/pbuilder/pbuilder-satisfydepends-apt&quot; Copy First of all, we need to overwrite our apt-sources list. Ubuntu places x86 sources seperately from ARM sources, so we need to do some jiggarypokery to get it working. Otherwise, it's just the same command as in PBuild. OTHER_MIRROR_LIST=( &quot;deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports focal main universe&quot; # Ubuntu splits up amd64 and arm64 repos &quot;deb [arch=amd64] http://gb.archive.ubuntu.com/ubuntu focal main universe&quot; ) OTHER_MIRROR=$(IFS='|' ; echo &quot;${OTHER_MIRROR_LIST[*]}&quot;) pdebuild --debbuildopts &quot;-us -uc&quot; -- --override-config --distribution focal --mirror &quot;&quot; --othermirror &quot;$OTHER_MIRROR&quot; --host-arch arm64 Copy -- ...: Options to pass to pbuilder: --host-arch arm64: Cross-compile for the arm64 architecture.--override-config: Needed to regenerate apt settings, since we're setting --othermirror--mirror &quot;&quot;: Leave blank, since we need to specify [arch=xxx] in --othermirror.--othermirror &quot;$OTHER_MIRROR&quot;: The deb sources.list entries for both arm64 (host) and amd64 (build).--distribution focal: Needed since we're regenerating apt settings. By default, the .deb file will be located in /var/cache/pbuilder/result/. "},{"title":"Podman​","type":1,"pageTitle":"Creating a .deb","url":"docs/deb#podman","content":"If you want to use podman (e.g. since you're using elementary OS, or pbuilder doesn't work since you don't have chroot support), you can use debuild manually. Install .deb build dependencies, as well as the build depenencies for EDGESec (see README.md) sudo apt install gnupg linux-headers-generic ubuntu-dev-tools apt-file -y Copy This will automatically call cmake in the background, using multiple threads (e.g. no need for j6) debuild -us -uc Copy Add the --no-pre-clean to prevent debuild from recompiling everything. This saves a lot of time during testing.-us -uc means do not sign the source package and .changes file. Now the deb should exist in the folder above this folder, e.g. cd ... "},{"title":"Editing the deb​","type":1,"pageTitle":"Creating a .deb","url":"docs/deb#editing-the-deb","content":"Beware of dependencies! The Depends: ${shlibs:Depends} line in debian/control means we automatically scan for shared libs. However, since we bundle in some shared libs, we must ignore these in debian/control, using the -l flag to dh_shlibdeps. This will tell dh_shlibdeps that a folder is our own private shared libs folder. Build dependencies: If we use git, make sure you also add ca-certificates, otherwise you'll get invalid certificate errors when doing git clones with https. Creating a new version of the .deb: To create a new version number for the .deb, add a new entry to debian/changelogwith the version you want, then rebuild the .deb. "},{"title":"Supported Devices","type":0,"sectionRef":"#","url":"docs/devices","content":"Supported Devices The EDGESec toolset was tested on the following devices: Raspberry Pi 3 B+Raspberry Pi 4 BPCengines apu2 platformNVIDIA Jetson Nano The compatible WiFi modems: USB Wifi Adapter for the Raspberry PiPanda Wireless PAU09 N600 Dual Band WiFi adapterCompex WLE200NX 802.11a/b/g/n miniPCI express wireless cardCompex WLE600VX 802.11ac miniPCI express wireless card The compatible hardware secure storage modules: ZYMKEY4i Raspberry Pi and Jetson Nano module","keywords":""},{"title":"Device Discovery","type":0,"sectionRef":"#","url":"docs/discovery","content":"Device Discovery The secure discovery service implements gateway and device discovery suing the network control service and mDNS reflector if available. For the gateway discovery we use the gRPC protocol and in particular we implemented the reverse access module with the following protocol buffer: syntax = &quot;proto3&quot;; package reverse_access; // The reverse access service definition. service Reverser { // Send client resource to server rpc SendResource (ResourceRequest) returns (ResourceReply) {} // Subscribe to client to server commands rpc SubscribeCommand (CommandRequest) returns (stream CommandReply) {} } message CommandRequest { string id = 1; } message CommandReply { string command = 1; string id = 2; } message ResourceRequest { uint32 type = 1; string meta = 2; bytes data = 3; } message ResourceReply { uint32 status = 1; } Copy The reverse service is used for discovering/listing the connected gateways as well as running generic commands on the gateway. As the reverse name suggests the reverse syncroniser connects to the cloud endpoint and executes a SubscribeCommand gRPC function that puts the synchroniser into the listening mode. Subsequently the cloud endpoint can send commands to the client. If a command involves accessing a resource then the SendResource function is used with the corresponding parameters. The second option for device discovery is by using a reflector for mDNS traffic. If a connected device wants to advertise its services to other subnets using mDNS than the reflectro intercepts the mDNS packet and forwards it to all available subnets. The third option is given by the device monitoring service, which monitors mDNS, DNS and other traffic data and stores the fingerprint and the qury string into the database for subsequent analaysis. The device discovery process can query the most recent mDNS traffic entry from the fingerprint database and find out the needed source and destination MAC address.","keywords":""},{"title":"Issues","type":0,"sectionRef":"#","url":"docs/issues","content":"","keywords":""},{"title":"aclocal-1.15: command not found​","type":1,"pageTitle":"Issues","url":"docs/issues#aclocal-115-command-not-found","content":"cd lib/libmnl-1.0.4 autoreconf -f -i Copy "},{"title":"GRPC/Protobuf linking issues​","type":1,"pageTitle":"Issues","url":"docs/issues#grpcprotobuf-linking-issues","content":"GRPC is only compatible with certain versions of Protobuf. Because of this, we recommend that you only use GRPC/Protobuf installed from your system (e.g. in your apt repository). If you have a custom version of GRPC installed in /usr/local, we recommend deleting it, by removing files in: /usr/local/bin (e.g. grpc-cpp-plugin)/usr/local/include (e.g. grpc++/)/usr/local/lib (e.g. libgrpc++.so)/usr/local/lib/pkgconfig (e.g. grpc++.pc) You can also compile GRPC and Protobuf from source, by setting DBUILD_GRPC_LIB=ON when running cmake. However, GRPC is difficult to cross-compile, which is why we recommend using the pre-compiled system version from apt. "},{"title":"\"Predictable names\" for WiFi interfaces​","type":1,"pageTitle":"Issues","url":"docs/issues#predictable-names-for-wifi-interfaces","content":"https://wiki.debian.org/NetworkInterfaceNames#legacy The scheme detailed above is the new standard default, but there's also a canonical way of overriding the default: you can use .link files to set up naming policies to suit your needs. Thus for instance if you have two PCs each of which has only a single wireless card, but one calls it wlp0s1 and the other wlp1s0, you can arrange for them both to use the name wifi0 to simplify sharing firewall configurations. For details see systemd.link(5). Here's a relatively futureproof &quot;manual&quot; version of the example given above:  #/etc/systemd/network/10-persistent-net.link [Match] MACAddress=01:23:45:67:89:ab [Link] Name=lan0 Copy Note: per systemd.link(5), you shouldn't use a name that the kernel might use for another interface (for example &quot;eth0&quot;). It is also possible to reorganize the naming policy by overriding /lib/systemd/network/99-default.link, for instance to insist that all network interfaces are named purely by MAC address:  #/etc/systemd/network/99-default.link [Match] OriginalName=* [Link] NamePolicy=mac MACAddressPolicy=persistent Copy The folder ./scripts contains the predictable_wifi_name.sh script to automaticall create the above lik file. Usage: sudo ./scripts/predictable_wifi_name.sh source_if_name destination_fi_name Copy "},{"title":"Stop wpa_supplicant listenning on WiFi interfaces (Raspberry Pi case)​","type":1,"pageTitle":"Issues","url":"docs/issues#stop-wpa_supplicant-listenning-on-wifi-interfaces-raspberry-pi-case","content":"Disable the entire wap_supplicant add the below line to /etc/dhcpcd.conf: nohook wpa_supplicant Copy Disable only for a particular wifi interface wlanx add the below line to /etc/dhcpcd.conf: denyinterfaces wlanx Copy "},{"title":"libmicrohttp TLS​","type":1,"pageTitle":"Issues","url":"docs/issues#libmicrohttp-tls","content":"If libgnutls and libcrypt are not installed, libmicrohttp cannot compile TLS support, and restsrv will fail to start. Because of this, make sure you have the following installed: (there should now be an error if they are not installed) sudo apt-get install libgnutls-dev libgnutls28-dev Copy "},{"title":"Running","type":0,"sectionRef":"#","url":"docs/running","content":"Running To run edgesec tool with the configuration file dev-config.ini located in ./build folder use: ./build/src/edgesec -c ./build/dev-config.ini Copy To enable verbose debug mode use: ./build/src/edgesec -c ./build/dev-config.ini -ddddd Copy The configuration file config.ini has been setup to work by default only when: running on Raspberry Pi (e.g. wlan1 is the name of Wifi USB AP and eth0 is the ethernet port)running after make install has been run Running edgesec tool with debug info and master password 12345 (verbose)​ sudo ./src/edgesec -c config.ini -s 12345 -ddddddddd Copy Running capsrv tool with syncing of br10 interface to localhost:8512 with grpc CA located in /cert/CA/CA.pem and data stored in ./db folder (verbose)​ sudo ./src/capsrv -i br10 -t 10 -n 10 -y default -w -s -p ./db -a localhost -o 8512 -k ./cert/CA/CA.pem -r 1000000,100 -dddddddddd Copy Running capsrv in cleaning mode only (verbose)​ Scans ./db/pcap-meta.sqlite until pcap capture has reached -b 20971520 KiB (aka 20 GiB). ./src/capsrv -p ./db -b 20971520 -dddddddd Copy Running restsrv on port 8513 with TLS certificate generation for localhost (verbose): sudo ./src/restsrv -s /tmp/edgesec-domain-server -p 8513 -z 32 -c localhost -t -dddddddd Copy Running revclient to localhost:8514 with grpc CA located in /cert/CA/CA.pem and data stored in ./db folder (verbose):​ Normally, you'd want to connect to a cloud server, but for testing, we can use localhost. Port and cert should match parameters passed to revsrv: sudo ./src/revclient -f ./db -a localhost -p 8514 -c ./cert/CA/CA.pem -dddddddd Copy Running revclient to localhost:8514 without grpc CA and data stored in ./db folder:​ sudo ./src/revclient -f ./db -a localhost -p 8514 Copy Cloud server - Running revsrv on port 8514 (verbose):​ The following programs are designed to run on a publically accesible server, that an EDGESec toolset can connect to. The GRPC certificate authority (-a &lt;example.CA.pem&gt;) MUST match the certificate authority passed to revclient on the EDGEsec device. Make sure that your server SSL certificate has the appropriate hostname (e.g. localhost, or edgesec-1.nqm-1.com). sudo ./revsrv -p 8514 -a /etc/edgesec/CA/CA.pem -c /etc/edgesec/revsrv/server.crt -k /etc/edgesec/revsrv/server.key -dddddd Copy","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/installation","content":"","keywords":""},{"title":"Dependencies​","type":1,"pageTitle":"Installation","url":"docs/installation#dependencies","content":"On Ubuntu, we need a C compiler, CMake, Doxygen, and libnl libraries: sudo apt update build_dependencies=( cmake # build-tool git # required to download dependencies ca-certificates # required for git+https downloads doxygen texinfo graphviz # documentation build-essential # C and C++ compilers libnl-genl-3-dev libnl-route-3-dev # netlink dependencies automake # required by libmicrohttpd for some reason? autopoint gettext # required by libuuid autoconf # required by compile_sqlite.sh libtool-bin # required by autoconf somewhere pkg-config # seems to be required by nDPI libjson-c-dev # mystery requirement flex bison # required by pcap libgnutls28-dev # required by libmicrohttpd libssl-dev # required by hostapd only. GRPC uses own version, and we compile OpenSSL 3 for EDGESec protobuf-compiler-grpc libprotobuf-dev libgrpc++-dev # GRPC, can be removed if -DBUILD_GRPC_LIB=ON libcmocka-dev # cmocka, can be removed if -DBUILD_CMOCKA_LIB=ON libmnl-dev # libmnl, can be removed if -DBUILD_LIBMNL_LIB=ON ) runtime_dependencies=( dnsmasq jq # required by predictable wifi name script ) sudo apt install -y &quot;${build_dependencies[@]}&quot; &quot;${runtime_dependencies[@]}&quot; Copy "},{"title":"Compile & Build​","type":1,"pageTitle":"Installation","url":"docs/installation#compile--build","content":"Compiling EDGESec is done with CMake. First, configure cmake in the build/ directory by running the following. mkdir build &amp;&amp; cd build &amp;&amp; cmake ../ Copy Setting -DLIB_MAKEFLAGS=&quot;--jobs=$(nproc)&quot; will mean that while compiling library dependencies,make commands will run using all CPU cores, greatly speeding this building (set a lower number if you have less RAM). cmake -B build/ -S . -DLIB_MAKEFLAGS=&quot;--jobs=$(nproc)&quot; Copy To build, you can then run: make Copy or to built on multiple core run: cmake --build build/ -j4 Copy -j4 means 4 jobs/threads, replace 4 with the amount of cores you want to use, equivalent to make -j4. After succesful compilation the binary will be located in ./build/src folder. "},{"title":"Installation​","type":1,"pageTitle":"Installation","url":"docs/installation#installation","content":"You can use the following to also install files into build/edgesec-dist: # Can do make and install in one step with # `cmake --build build/ --target install -j4` cmake --install build/ Copy "},{"title":"Installing to custom location​","type":1,"pageTitle":"Installation","url":"docs/installation#installing-to-custom-location","content":"Set -DCMAKE_INSTALL_PREFIX=&lt;YOUR-LOCATION-HERE&gt; to build for a different location: MAKEFLAGS=&quot;--jobs=$(nproc)&quot; cmake -B build/ -S . -DCMAKE_INSTALL_PREFIX=/tmp/example-build cmake --build build/ --target install -j4 Copy This will also automatically update config.ini to have all paths point to the installed location. You can also use the following to install to a different location than the one you built for. # Will update config.ini, but will not update RPATHS!!! cmake --install build/ --prefix &lt;new-location&gt; Copy This will not update the RPATHs (since they have to be known at compile time). However, as we use relative RPATHs, as long as you don't change the folder structure, it will be fine. Please configure cmake with -DCMAKE_INSTALL_PREFIX and recompile if you want to change the RPATH. "},{"title":"Testing​","type":1,"pageTitle":"Installation","url":"docs/installation#testing","content":"To compile the tests use: cmake -B build/ -S . # configure CMAKE cmake --build build/ -j4 # or make -j4 cmake --build build/ --target test -j4 # or `make test` Copy To run each test individually, the test binaries can be located in ./build/tests folder. "},{"title":"Developer Documentation​","type":1,"pageTitle":"Installation","url":"docs/installation#developer-documentation","content":"To compile the docs from ./build folder: make doxydocs Copy See ./docs for how to build the developer doxygen documentation website. "},{"title":"Secure Storage","type":0,"sectionRef":"#","url":"docs/storage","content":"Secure Storage The secure storage service implements a key/value store for all other services to store and retrieve encrypted keys or data. To encrypt data the secure storage generates keys that are encrypted using the hardware secure element or a user supplied passphrase. The secure storage is implemented as a sqlite database with two tables secrets and store. The schema for the secrets table is as follows: CREATE TABLE secrets (id TEXT NOT NULL, value TEXT, salt TEXT, iv TEXT, PRIMARY KEY (id)); Copy where id is the ID of the generated key, value is the value of the key, iv the the IV used to encrypt and decrypt the key and salt is the salt sed ofr encryption and decryption when a userpasspharse is supplied. An example of the secrets table row is given below: ID\tVALUE\tSALT\tIVmaster\tLbknNO6o+s+u1b4wg9eGzQjHCanicVtDlDJBWZ0u4VaV25oIUCt1b5bthzLwhQO0\tZ95m5G/+jgb3ga0dufa//w\thka2MmSUkJUJBf7TQMYnug rest\ta2UiZR/DLYb3hX61ZQ7Mb/vdVVIchJzkuNnoIhLDCHXe9453IlWjOfOymodUZIsq\tRLdlnafYj7279lne7A5UoA\tlgTKNxgxbeCxg4VySS/7vw 94:b9:7e:15:47:95\tlPVf5wqMnb9+8Q8Cik5oetOI9MfA6qjPm1tKTR3WGPWgZYtaybEeDKWGX/x4EUUB\tgFvI5tfeHANOafJlFsHXpg\tmH2yeX/FEvJd1ilg25Zwcg The value, salt and iv are base64 encoded. When a user or service wants to store a key/value she will need to provide and ID for the key that will be used to encrypt/decrypt the user's value. If such an ID does not exists in the secrets table, the service will randomly generate one and encrypt it using the hardware secure element or the user supplied passphrase. When the user provides the passphrase the service will generate an encryption key using the \\b salt and Password-Based Key Derivation Function Password-Based Key Derivation Function 2. The derived key is not stored on the device. If the user instead uses the hardware secure element, the key derivation, encryption and decryption is done in secure memory. Each key/value is stored in the store table with the following schema: CREATE TABLE store (key TEXT NOT NULL, value TEXT, id TEXT, iv TEXT, PRIMARY KEY (key)); Copy where key is the key for the value, value is the value to be stored, id is the key id used to encrypt/decrypt the value and iv is the IV used to encrypt/decrypt the value. An example of the store table rows is given below. KEY\tVALUE\tID\tIV7815f8ce-57b8-49c8-9121-5b98986cbccd\tGCM564Ugwyh0bW3f4JuFkw\tmaster\tJa0pz9cdH7p3Q+BBP2MIrw db07c38a-2842-4f45-9672-74d57ec99e63\t23cHWe6r033czxopWsv6Ng\tmaster\tFU7hUGGbifro65cv0u0OwQ 1a35f54d-c5f9-4072-85b0-4b40f8fb4a14\tLR3iRw6SrN/pWKSTJvNtrA\tmaster\tx9hFentG2Q6iynHXCk2ktA 831ffbb1-2e79-422a-bdad-e9e96a56d568\tCdoxKK4PbDvWD9cOdRcTXQ\tmaster\tRHR1AGsjpWVHDR4VN2PiLA The value and iv is base64 encoded. Each row of the key/value store contains the id of the key that was used to encrypt/decrypt the value. The encryption algorithm used is AES 256 CBC.","keywords":""}]